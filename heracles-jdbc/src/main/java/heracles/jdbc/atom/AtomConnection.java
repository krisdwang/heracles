package heracles.jdbc.atom;

import heracles.jdbc.common.exception.ExceptionUtils;

import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.NClob;
import java.sql.PreparedStatement;
import java.sql.SQLClientInfoException;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Executor;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.datasource.DataSourceUtils;

public class AtomConnection implements Connection {

	private static final Logger LOGGER = LoggerFactory.getLogger(AtomConnection.class);

	private AtomDataSource atomDataSource;

	private Connection targetConnection;

	private Statement targetStatement;

	private boolean closed = false;

	public AtomDataSource getAtomDataSource() {
		return atomDataSource;
	}

	public void setAtomDataSource(AtomDataSource atomDataSource) {
		this.atomDataSource = atomDataSource;
	}

	public Connection getTargetConnection() {
		return targetConnection;
	}

	public void setTargetConnection(Connection targetConnection) {
		this.targetConnection = targetConnection;
	}

	public Statement getTargetStatement() {
		return targetStatement;
	}

	public void setTargetStatement(Statement targetStatement) {
		this.targetStatement = targetStatement;
	}

	public Set<Statement> getTargetStatements() {
		return targetStatements;
	}

	public void setTargetStatements(Set<Statement> targetStatements) {
		this.targetStatements = targetStatements;
	}

	private boolean readOnly;
	private boolean autoCommit = true;
	private int transactionIsolation = -1;

	private Set<Statement> targetStatements = new HashSet<Statement>();

	public AtomConnection(AtomDataSource atomDataSource) throws SQLException {
		this.atomDataSource = atomDataSource;
		this.targetConnection = DataSourceUtils.getConnection(this.atomDataSource.getTargetDataSource());
	}

	// FIXME kriswang getConnection(username, password)
	public AtomConnection(AtomDataSource atomDataSource, String username, String password) throws SQLException {
		this.atomDataSource = atomDataSource;
//		this.targetConnection = this.atomDataSource.getTargetDataSource().getConnection(username, password);
		this.targetConnection = DataSourceUtils.getConnection(this.atomDataSource.getTargetDataSource());
	}

	private void checkClosed() throws SQLException {
		if (closed) {
			throw new SQLException();
		}
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		try {
			return (T) this;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return this.getClass().isAssignableFrom(iface);
	}

	@Override
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		checkClosed();
		AtomPreparedStatement preparedStatement = new AtomPreparedStatement(this);
		preparedStatement.setAutoCommit(autoCommit);
		preparedStatement.setReadOnly(readOnly);
		preparedStatement.setSql(sql);

		return preparedStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		AtomPreparedStatement preparedStatement = (AtomPreparedStatement) prepareStatement(sql);
		preparedStatement.setAutoGeneratedKeys(autoGeneratedKeys);
		return preparedStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
		AtomPreparedStatement preparedStatement = (AtomPreparedStatement) prepareStatement(sql);
		preparedStatement.setColumnIndexes(columnIndexes);
		return preparedStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
		AtomPreparedStatement preparedStatement = (AtomPreparedStatement) prepareStatement(sql);
		preparedStatement.setColumnNames(columnNames);
		return preparedStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
			throws SQLException {
		AtomPreparedStatement preparedStatement = (AtomPreparedStatement) prepareStatement(sql);
		preparedStatement.setResultSetType(resultSetType);
		preparedStatement.setResultSetConcurrency(resultSetConcurrency);
		return preparedStatement;
	}

	@Override
	public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
			int resultSetHoldability) throws SQLException {
		AtomPreparedStatement preparedStatement = (AtomPreparedStatement) prepareStatement(sql, resultSetType,
				resultSetConcurrency);
		preparedStatement.setResultSetHoldability(resultSetHoldability);
		return preparedStatement;
	}

	@Override
	public Statement createStatement() throws SQLException {
		checkClosed();

		AtomStatement statement = new AtomStatement(this);
		statement.setAutoCommit(autoCommit);
		statement.setReadOnly(readOnly);
		
		targetStatements.add(statement);

		return statement;
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
		AtomStatement statement = (AtomStatement) createStatement();
		statement.setResultSetType(resultSetType);
		statement.setResultSetConcurrency(resultSetConcurrency);
		return statement;
	}

	@Override
	public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability)
			throws SQLException {
		AtomStatement statement = (AtomStatement) createStatement(resultSetType, resultSetConcurrency);
		statement.setResultSetHoldability(resultSetHoldability);
		return statement;
	}

	@Override
	public CallableStatement prepareCall(String sql) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency,
			int resultSetHoldability) throws SQLException {
		throw new UnsupportedOperationException("prepareCall");
	}

	@Override
	public String nativeSQL(String sql) throws SQLException {
		return this.targetConnection.nativeSQL(sql);
	}

	@Override
	public void setAutoCommit(boolean autoCommit) throws SQLException {
		this.autoCommit = autoCommit;
	}

	@Override
	public boolean getAutoCommit() throws SQLException {
		return this.autoCommit;
	}

	@Override
	public void commit() throws SQLException {
		checkClosed();

		if (autoCommit) {
			return;
		}

		try {
			targetConnection.commit();
		} catch (Exception e) {
			LOGGER.error("AtomConnection commit: tx commit is error:" + e.getMessage());
			throw new SQLException(e);
		}

	}

	@Override
	public void rollback() throws SQLException {
		checkClosed();

		if (autoCommit) {
			return;
		}

		try {
			targetConnection.rollback();
		} catch (Exception e) {
			LOGGER.error("AtomConnection rollback: tx rollback is error:" + e.getMessage());
			throw new SQLException(e);
		}
	}

	@Override
	public void close() throws SQLException {
		if (closed) {
			return;
		}

		try {
			List<SQLException> sqlExceptions = new ArrayList<SQLException>();

			for (Statement stmt : targetStatements) {
				try {
					stmt.close();
				} catch (SQLException e) {
					LOGGER.error("AtomConnection close: conn close is error:" + e.getMessage());
					sqlExceptions.add(e);
				}
			}

			try {
				targetConnection.close();
			} catch (SQLException e) {
				LOGGER.error("AtomConnection close: conn close is error:" + e.getMessage());
				sqlExceptions.add(e);
			}

			ExceptionUtils.throwSQLExceptions(LOGGER, sqlExceptions);
		} finally {
			closed = true;
			targetStatements.clear();
		}

	}

	@Override
	public boolean isClosed() throws SQLException {
		return closed;
	}

	@Override
	public DatabaseMetaData getMetaData() throws SQLException {
		checkClosed();
		return new AtomDatabaseMetaData(atomDataSource.getTargetDataSource());
	}

	@Override
	public void setReadOnly(boolean readOnly) throws SQLException {
		checkClosed();
		this.readOnly = readOnly;
	}

	@Override
	public boolean isReadOnly() throws SQLException {
		return readOnly;
	}

	@Override
	public void setCatalog(String catalog) throws SQLException {
		this.targetConnection.setCatalog(catalog);

	}

	@Override
	public String getCatalog() throws SQLException {
		return this.targetConnection.getCatalog();
	}

	@Override
	public void setTransactionIsolation(int level) throws SQLException {
		checkClosed();
		this.transactionIsolation = level;
	}

	@Override
	public int getTransactionIsolation() throws SQLException {
		return transactionIsolation;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return this.targetConnection.getWarnings();
	}

	@Override
	public void clearWarnings() throws SQLException {
		this.targetConnection.clearWarnings();
	}

	@Override
	public Map<String, Class<?>> getTypeMap() throws SQLException {
		return this.targetConnection.getTypeMap();
	}

	@Override
	public void setTypeMap(Map<String, Class<?>> map) throws SQLException {
		this.targetConnection.setTypeMap(map);
	}

	@Override
	public void setHoldability(int holdability) throws SQLException {
		this.targetConnection.setHoldability(holdability);
	}

	@Override
	public int getHoldability() throws SQLException {
		return this.targetConnection.getHoldability();
	}

	@Override
	public Savepoint setSavepoint() throws SQLException {
		return this.targetConnection.setSavepoint();
	}

	@Override
	public Savepoint setSavepoint(String name) throws SQLException {
		return this.targetConnection.setSavepoint(name);
	}

	@Override
	public void rollback(Savepoint savepoint) throws SQLException {
		this.targetConnection.rollback(savepoint);

	}

	@Override
	public void releaseSavepoint(Savepoint savepoint) throws SQLException {
		this.targetConnection.releaseSavepoint(savepoint);
	}

	@Override
	public Clob createClob() throws SQLException {
		return this.targetConnection.createClob();
	}

	@Override
	public Blob createBlob() throws SQLException {
		return this.targetConnection.createBlob();
	}

	@Override
	public NClob createNClob() throws SQLException {
		return this.targetConnection.createNClob();
	}

	@Override
	public SQLXML createSQLXML() throws SQLException {
		return this.targetConnection.createSQLXML();
	}

	@Override
	public boolean isValid(int timeout) throws SQLException {
		return this.targetConnection.isValid(timeout);
	}

	@Override
	public void setClientInfo(String name, String value) throws SQLClientInfoException {
		this.targetConnection.setClientInfo(name, value);
	}

	@Override
	public void setClientInfo(Properties properties) throws SQLClientInfoException {
		this.targetConnection.setClientInfo(properties);
	}

	@Override
	public String getClientInfo(String name) throws SQLException {
		return this.targetConnection.getClientInfo(name);
	}

	@Override
	public Properties getClientInfo() throws SQLException {
		return this.targetConnection.getClientInfo();
	}

	@Override
	public Array createArrayOf(String typeName, Object[] elements) throws SQLException {
		return this.targetConnection.createArrayOf(typeName, elements);
	}

	@Override
	public Struct createStruct(String typeName, Object[] attributes) throws SQLException {
		return this.targetConnection.createStruct(typeName, attributes);
	}

	@Override
	public void setSchema(String schema) throws SQLException {
		this.targetConnection.setSchema(schema);
	}

	@Override
	public String getSchema() throws SQLException {
		return this.targetConnection.getSchema();
	}

	@Override
	public void abort(Executor executor) throws SQLException {
		this.targetConnection.abort(executor);
	}

	@Override
	public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException {
		this.targetConnection.setNetworkTimeout(executor, milliseconds);
	}

	@Override
	public int getNetworkTimeout() throws SQLException {
		return this.targetConnection.getNetworkTimeout();
	}

}
