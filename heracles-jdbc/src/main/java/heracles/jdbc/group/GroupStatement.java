package heracles.jdbc.group;

import heracles.jdbc.common.exception.ExceptionUtils;
import heracles.jdbc.executor.merge.MergeExecutor;
import heracles.jdbc.parser.Parser;
import heracles.jdbc.parser.exception.SQLParserException;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GroupStatement implements Statement {

	private static final Logger LOGGER = LoggerFactory.getLogger(GroupStatement.class);

	private GroupConnection groupConnection;
	protected MergeExecutor mergeExecutor = new MergeExecutor();
	private Statement targetStatement;

	public GroupConnection getGroupConnection() {
		return groupConnection;
	}

	public void setGroupConnection(GroupConnection groupConnection) {
		this.groupConnection = groupConnection;
	}

	public Statement getTargetStatement() {
		return targetStatement;
	}

	public void setTargetStatement(Statement targetStatement) {
		this.targetStatement = targetStatement;
	}

	protected Parser parser = null;

	private boolean closed;
	private boolean readOnly;
	private boolean autoCommit = true;
	private GroupConnection connectionWrapper;
	private int resultSetType = -1;
	private int resultSetConcurrency = -1;
	private int resultSetHoldability = -1;
	protected Set<ResultSet> attachedResultSets = new HashSet<ResultSet>();
	protected List<Statement> actualStatements = new ArrayList<Statement>();
	protected ResultSet resultSet;
	protected boolean moreResults;
	protected int updateCount;

	public GroupStatement(GroupConnection groupConnection) throws SQLException {
		this.groupConnection = groupConnection;
	}

	public boolean isReadOnly() {
		return readOnly;
	}

	public void setReadOnly(boolean readOnly) {
		this.readOnly = readOnly;
	}

	public boolean isAutoCommit() {
		return autoCommit;
	}

	public void setAutoCommit(boolean autoCommit) {
		this.autoCommit = autoCommit;
	}

	public void setResultSetType(int resultSetType) {
		this.resultSetType = resultSetType;
	}

	public void setResultSetHoldability(int resultSetHoldability) {
		this.resultSetHoldability = resultSetHoldability;
	}

	public void setResultSetConcurrency(int resultSetConcurrency) {
		this.resultSetConcurrency = resultSetConcurrency;
	}

	public GroupConnection getConnectionWrapper() {
		return connectionWrapper;
	}

	public void setConnectionWrapper(GroupConnection connection) {
		this.connectionWrapper = connection;
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		try {
			return (T) this;
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return this.getClass().isAssignableFrom(iface);
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		checkClosed();

		try {
			Connection conn = this.getGroupConnection().getReadTargetConnection(false);
			conn.setAutoCommit(isAutoCommit());

			targetStatement = _createStatement(conn);

			groupConnection.getTargetConnections().add(conn);
			groupConnection.getTargetStatements().add(targetStatement);

			ResultSet resultSet = targetStatement.executeQuery(sql);
			attachedResultSets.add(resultSet);
			this.resultSet = new GroupResultSet(resultSet);

			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("GroupStatement executeQuery: the targetSql is [" + sql + "];  number of result rows: "
						+ resultSet.getRow());
			}
		} catch (Exception e) {
			throw new SQLException(e);
		}

		this.moreResults = false;
		this.updateCount = -1;

		return this.resultSet;
	}

	private Statement _createStatement(Connection connection) throws SQLException {
		Statement statement;
		if (this.resultSetType != -1 && this.resultSetConcurrency != -1 && this.resultSetHoldability != -1) {
			statement = connection.createStatement(this.resultSetType, this.resultSetConcurrency,
					this.resultSetHoldability);
		} else if (this.resultSetType != -1 && this.resultSetConcurrency != -1) {
			statement = connection.createStatement(this.resultSetType, this.resultSetConcurrency);
		} else {
			statement = connection.createStatement();
		}
		return statement;
	}

	private int _executeUpdate(String sql, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames)
			throws SQLException {
		checkClosed();

		int affectedRows = 0;

		try {

			Connection conn = this.getGroupConnection().getWriteTargetConnection();
			conn.setAutoCommit(isAutoCommit());

			targetStatement = _createStatement(conn);

			groupConnection.getTargetConnections().add(conn);
			groupConnection.getTargetStatements().add(targetStatement);
			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("GroupStatement _executeUpdate: the targetSql is [" + sql + "]");
			}
			if (autoGeneratedKeys == -1 && columnIndexes == null && columnNames == null) {
				affectedRows += targetStatement.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
			} else if (autoGeneratedKeys != -1) {
				affectedRows += targetStatement.executeUpdate(sql, autoGeneratedKeys);
			} else if (columnIndexes != null) {
				affectedRows += targetStatement.executeUpdate(sql, columnIndexes);
			} else if (columnNames != null) {
				affectedRows += targetStatement.executeUpdate(sql, columnNames);
			} else {
				affectedRows += targetStatement.executeUpdate(sql, Statement.RETURN_GENERATED_KEYS);
			}
		} catch (Exception e) {
			throw new SQLException(e);
		}

		this.resultSet = null;
		this.moreResults = false;
		this.updateCount = affectedRows;

		return affectedRows;
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		return _executeUpdate(sql, -1, null, null);
	}

	@Override
	public void close() throws SQLException {
		if (closed) {
			return;
		}

		try {
			List<SQLException> sqlExceptions = new ArrayList<SQLException>();

			for (ResultSet resultSet : attachedResultSets) {
				try {
					resultSet.close();
				} catch (SQLException e) {
					sqlExceptions.add(e);
				}

			}

			for (Statement stmt : actualStatements) {
				try {
					stmt.close();
				} catch (SQLException e) {
					sqlExceptions.add(e);
				}
			}

			ExceptionUtils.throwSQLExceptions(LOGGER, sqlExceptions);
		} finally {
			closed = true;
			attachedResultSets.clear();
			actualStatements.clear();
			resultSet = null;
		}
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int getMaxRows() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void cancel() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		return _execute(sql, -1, null, null);
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		return this.resultSet;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return this.updateCount;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return this.moreResults;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int getFetchDirection() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int getFetchSize() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return resultSetConcurrency;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	/*
	 * ======================================================================== executeBatch
	 * ======================================================================
	 */
	protected List<String> batchedArgs;

	@Override
	public void addBatch(String sql) throws SQLException {
		checkClosed();
		if (batchedArgs == null) {
			batchedArgs = new LinkedList<String>();
		}
		if (sql != null) {
			batchedArgs.add(sql);
		}
	}

	@Override
	public void clearBatch() throws SQLException {
		checkClosed();
		if (batchedArgs != null) {
			batchedArgs.clear();
		}
	}

	@Override
	public int[] executeBatch() throws SQLException {
		try {
			checkClosed();

			if (batchedArgs == null || batchedArgs.isEmpty()) {
				return new int[0];
			}

			Connection conn = this.getGroupConnection().getWriteTargetConnection();
			conn.setAutoCommit(isAutoCommit());

			return executeBatchOnConnection(conn, this.batchedArgs);
		} finally {
			if (batchedArgs != null)
				batchedArgs.clear();
		}
	}

	private int[] executeBatchOnConnection(Connection conn, List<String> batchedSqls) throws SQLException {
		Statement stmt = _createStatement(conn);
		for (String sql : batchedSqls) {
			stmt.addBatch(sql);
		}
		return stmt.executeBatch();
	}

	/*
	 * ======================================================================== END
	 * ======================================================================
	 */

	@Override
	public Connection getConnection() throws SQLException {
		return connectionWrapper;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return moreResults;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		return _executeUpdate(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		return _executeUpdate(sql, -1, columnIndexes, null);
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		return _executeUpdate(sql, -1, null, columnNames);
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return _execute(sql, autoGeneratedKeys, null, null);
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return _execute(sql, -1, columnIndexes, null);
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return _execute(sql, -1, null, columnNames);
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return resultSetHoldability;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return closed;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean isPoolable() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		throw new UnsupportedOperationException();
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		throw new UnsupportedOperationException();
	}

	protected void checkClosed() throws SQLException {
		if (closed) {
			throw new SQLException();
		}
	}

	private boolean _execute(String sql, int autoGeneratedKeys, int[] columnIndexes, String[] columnNames)
			throws SQLException {
		checkClosed();
		checkParsed(sql);

		switch (parser.getParserResult().getType()) {
		case SELECT:
			executeQuery(sql);
			return true;
		case DELETE:
		case INSERT:
		case UPDATE:
			if (autoGeneratedKeys == -1 && columnIndexes == null && columnNames == null) {
				executeUpdate(sql);
			} else if (autoGeneratedKeys != -1) {
				executeUpdate(sql, autoGeneratedKeys);
			} else if (columnIndexes != null) {
				executeUpdate(sql, columnIndexes);
			} else if (columnNames != null) {
				executeUpdate(sql, columnNames);
			} else {
				executeUpdate(sql);
			}
			return false;
		default:
			throw new SQLParserException("GroupStatement _execute:not support this sql : " + sql
					+ ";statement type is " + parser.getParserResult().getType());
		}
	}

	protected void checkParsed(String sql) {
		parser = new Parser(sql, this.getGroupConnection().getGroupDataSource().getRules());
	}
}
